
본 노트는 ReSTIR 원문을 이해하기 위해 요약한 노트입니다.

---

수백 만 개의 동적인 광원을 몬테 카를로 적분법을 사용하여 효과적으로 렌더링하는 것은 매우 어려운 문제로 남아있습니다.
심지어 실시간성이 중요하지 않은 offline 렌더링 시스템에서조차 쉽지 않은 일이죠.

이 문제를 해결하기 위해 ReSTIR이라는 새로운 알고리즘을 개발하였습니다.
ReSTIR 알고리즘은 그러한 수백 만개의 동적인 광원을 높은 품질과 상호작용성을 유지하며 렌더링할 수 있게 도와줍니다.
또한, 기존 방식에서 요구되었던 복잡한 자료구조를 필요로 하지 않습니다.

ReSTIR에서는 광원 샘플들의 집합으로부터 다시 샘플링을 진행합니다.
이때 해당 샘플과 관련있는 주위의 샘플들에 대한 정보를 반영하기 위해서 공간과 시간에 대한 샘플링을 합니다.

이 알고리즘을 통해 Unbiased 몬테 카를로 추정량을 유도할 수 있고, 동일한 에러 수준을 유지하며 최신 방법들보다 약 60배 빠른 성능을 보여줍니다.
Biased 추정량은 Unbiased보다 노이즈를 더 감소시킬 수 있고, 약 35~60배 더 빠른 성능을 보여줍니다. (단 biased하기 때문에 에너지 보존을 지킬 수 없고, 렌더링 과정에서 일정량에 에너지가 소실됩니다.)

![](../../../../images/Pasted%20image%2020240603221243.png)
- ReSTIR 알고리즘은 기본적으로 샘플링 퀄리티를 향상시키는데 초점을 맞추고 있습니다. 렌더링된 결과 이미지를 NVIDIA의 OptiX와 같은 denoiser(노이즈 제거기)를 사용하면 이미지 퀄리티를 더 향상시킬 수 있습니다.

# 1. Introduction

최근 몇년 동안, 몬테 카를로 적분법 기반의 path tracing은 많은 offline 렌더링에서 사용되었습니다. 
특수 목적의 GPU 하드웨어가 (예를 들면, Nvidia RTX) ray intersection 테스트를 지원하기 시작한 이후, 실시간 렌더링 어플리케이션에서도 그 사용 사례가 점차 늘어나고 있습니다.  
하지만 실시간에 대한 제약이 없는 offline rendering에서도 많은 광원으로부터의 d직접을 다루는 것은 어려운 문제입니다. 
 
문제를 푸는 것을 어렵게 만드는 데는 여러 요인이 있습니다.
  - 모든 광원에 대한 shadow ray들을 추적하는 것
  - 어떠한 한 점에 대한 각각의 빛의 가시성을 고려하며 그 점에 가장 많은 기여를 하는 빛들을 알아내는 것
  - 한 점에 대한 scattering function에 대한 분포를 알아내는 것
  - 광원의 세기와 발광 특성을 고려하는 것

이 상황에서 실시간성까지 적용하고 하면, 문제가 더 복잡해지게 됩니다. 
실시간 어플리케이션에서는 렌더링 하고자 하는 scene이 동적입니다. scene의 상태는 어플리케이션을 사용하는 유저에 의해 바뀔 수 있기 때문에, 렌더러는 다음 scene이 어떻게 변할지 예측할 수 없습니다.
게다가, 현재는 각 픽셀에서 추적할 수 있는 ray의 수가 많지 않기에 중요한 광원들을 찾아내는 것이 훨씬 더 중요하게 됩니다. (그렇지 못하다면, 렌더링 결과에 많은 노이즈가 존재하겠죠.)
하지만, 실시간성을 만족시키기 위해선 광원 샘플링을 도와주는 자료구조를 만들고 업데이트하는데 시간적 제약이 존재합니다.
위에 나열된 내용들은 이 논문에서 다루는 first camera 정점에 대한 직접광을 계산하는 제한된 경우에도 적용됩니다.

이러한 제약들을 극복하기 위해, denoising분야 와 하나의 픽셀 당 적은 샘플로만 렌더링된 noisy 이미지로부터 reconstructing하는 분야에서 많은 연구가 이루어져 왔습니다. 
실시간과 오프라인 렌더링 분야에서 큰 진전이 있어온 와중에, 실시간 denoiser에서는 필터링에 사용되는 시간이 frame time의 일부분을 잡아먹기 때문에 제한된 처리 시간만이 허용됐습니다. 
노이즈 제거 문제는 특히 샘플 수가 적은 이미지에서 더 어려워집니다. 때문에 샘플들의 퀄리티를 향상시켜서 denoiser에게 전달한다면 상당한 효과를 얻을 수 있습니다. (ReSTIR은 샘플의 퀄리티를 향상하는 알고리즘이니 궁합이 좋네요.)

이 논문에서는 많은 광원으로부터 한번의 반사가 일어나는 direct lighting 에 대해 샘플을 하는 방법을 소개합니다. 이 방법은 완전히 동적인 scene을 가지고 있는 실시간 ray tracing 에도 적용됩니다.

ReSTIR은 Resampled Importance sampling(줄여서 RIS)위에서 만들어졌습니다. 
RIS는 하나의 확률 분포에서 샘플들의 집합을 취하고, 우리가 적분하고 싶은 함수와 더 잘 들어맞는 또 다른 분포를 이용해서 이전에 뽑았던 샘플들에 대한 가중치가 적용된 부분집합을 선택하는 방법입니다.

그러나 ReSTIR의 차이점은 이전에 RIS가 응용되었던 방법과 달리 reservoir라는 고정된 크기의 자료구조를 이용하여 오직 받아들일 수 있는 샘플들만 reservoir에 저장하여 안정적이면서도 실시간의 성능을 낼 수 있다는 것입니다.

Reservoir를 이용하여, 더 이상 고정 크기의 배열보다 복잡한 자료구조를 필요로하지 않습니다. 그러면서도 시간적인 이웃과 공간적인 이웃으로부터의 정보를 활용함으로써, 각각의 픽셀의 직접광 샘플링 확률 밀도 함수를 통계적으로, 점진적으로 그리고 위계적으로 향상시킵니다.

해당 논문에서는 spaital과 temporal단어를 많이 언급합니다. 지금부터 두 단어를 한 번에 부를 때는 '시공간'이라는 단어로, 각각에 대해서는 '시간적인', '공간적인' 이라는 형용사로 치환하여 부르겠습니다.

최근 실시간 denoising 알고리즘들은 시공간 이웃들의 픽셀 색상을 재사용합니다. 반면, ReSTIR 알고리즘은 시공간 이웃에 대한 샘플링 확률들을 사용하는 것이 차이점입니다. 이 샘플링 확률들을 재사용하는 컨셉이 알고리즘을 unbiased하게 만들 수 있는 핵심 요소가 됩니다.

Unbiased ReSTIR은 Biased 모드로 바꾸는 것이 가능합니다. Biased ReSTIR을 적용하면 기하적으로 불연속적인 부분들에 대해 실제보다 어두워지는 단점이 있지만, unbiased 알고리즘보다 노이즈를 더 제거할 수 있는 장점이 있습니다.


---
# 2. Preliminaries

이 섹션에서는 수식 용어의 정확성을 위해, 한국어 번역이 이상한 term은 그대로 사용하겠습니다.

- ## 1. Rendering equation against BSDF (렌더링 방정식)
	- $\rho$ - BSDF 
	- $L_e$ - emitted radiance
	- $V$ - x,y 사이의 상호적인 가시성. (x 로부터 y를 볼 수 있는지, y로 부터 x를 볼 수 있는지)
	- $G$ - 기하적인 정보 
		- 거리 제곱의 역 (inverse squred distance) :
		  (역자 주)ReSTIR 알고리즘은 앞서 direct lighting에 대한 문제를 푼다고 언급한 바가 있습니다. 모든 가능한 방향에 대해 평균을 취하는 이전 방법과 달리, ReSTIR 알고리즘은 모든 광원의 모든 가능한 점에 대해서 평균을 취합니다. 
		  즉, 물체의 표면과 광원 사이의 거리와 상관없이 항상 동일한 점에 대한 평균값을 취하게 될 것이고, 이는 렌더링하는 이미지에 부정확한 결과를 초래하게 될 것입니다. 
		   따라서 표면과 광원 사이의 거리 제곱의 역을 취해 이 부정확한 현상을 보정해주는 것입니다.
		- consine term : (역자 주)빛의 세기를 보정해주는 역할을 합니다. 실제로는 빛이 어떤 표면에 반사되어 우리 눈에 들어올 때는, 해당 표면이 빛이 들어오는 각도에 따라 눈에 들어오는 양이 바뀝니다. 
		   하지만, ray tracing에서는 빛을 가상의 카메라로부터 쏘기 때문에 표면이 어떻게 회전하든 동일한 색깔이 광원으로부터 샘플링될 가능성이 있습니다. 
		   이를 보정해주기 위해 0과 1 사이의 값을 갖는 cosine함수를 이용하여 입사각에 따라 빛의 세기를 보정할 수 있습니다.
$$L(y,w)=\int_A\rho(y, \vec{yx} \leftrightarrow \vec{\omega})L_e(x\rightarrow y)G(x\leftrightarrow y)V(x\leftrightarrow y)dA_x$$

단순함을 위해, 바라보는 방향인 $\vec{\omega}$와 shading 지점인 $y$를 수식에서 제거해봅시다. 
또한 적분을 취할 미소 면적(differential area)를 $dx$로 표기하고, 적분 함수를 $f(x)$로 치환하면, 식을 다음과 같이 줄여 쓸 수 있습니다.

$$L = \int_Af(x)dx$$, 여기서 $f(x)=\rho(x)L_e(x)G(x)V(x)$

- ## 2. Importance sampling (중요도 샘플링)
	표준 몬테 카를로 중요도 샘플링은 원래 확률 밀도 함수로부터 N개의 샘플을 선택하여 적분을 추정하는 방법입니다.
	지금부터 Importance Sampling을 줄여서 IS라 칭하겠습니다.
	IS에 대한 수식은 다음과 같습니다.
	
	$${\langle L\rangle}_{is}^{N}=\frac{1}{N}\sum_{i=1}^{N}\frac{f(x_i)}{p(x_i)}\approx L$$
	
	(역자 주)중요도 샘플링에 대해 간략히 설명해보겠습니다. 우리는 적분하고자 하는 함수를 가지고 있습니다. 
	중요도 샘플링을 적용하지 않고 몬테 카를로 추정치를 구하면 N(샘플 개수)이 무한히 증가할 때, 추정치는 true integral인 $L$에 수렴하게 될 것입니다. 하지만 매우 많은 샘플이 필요할테고, 샘플이 적어질수록 렌더링 결과에는 많은 노이즈가 생기게 될 것입니다.
	적은 샘플로 더 잘할 수 있는 방법은 없을까요? 바로 확률 밀도 함수를 이용하는 것입니다. 
	우리가 적분 하고자 함수 $f$에 대해, $f(x_i)$가 어떠한 확률로 발생할지 결정할 수 있는 임의의 확률 밀도 함수 $p(x_i)$를 알고 있다고 가정합시다.
	$f$에 대한 샘플링을 진행하면, 당연히 높은 발생 확률을 가지고 있는 구간에서 많은 샘플이 발생할 것입니다.
	그렇다면, 자주 발생하는 구간이 적분 값에 큰 영향을 미치게 될 것입니다. 
	하지만 아직 간과한 것이 있습니다. 
	너무 많은 샘플이 중요한 구간에서만 샘플링 된다면 어떻게 될까요? 그렇다면 샘플들의 값을 평균을 취한 결과는 우리가 기대한 값과 많이 다르게 될 것입니다. 왜냐하면 outlier들이 평균을 보정해주는 역할을 다하지 못했기 때문입니다.
	우리가 중요도 샘플링 공식에서 확률 값을 분모에 배치한 것이 바로 이 문제를 해결하기 위함입니다. 
	- 확률이 높다 -> 분모가 커진다 -> 전체 값은 작아진다.
	- 확률이 낮다 -> 분모가 작아진다 -> 전체 계산 값은 커진다.
	위와 같은 수학적 원리를 사용하여 우리는 올바른 중요도 샘플링을 진행할 수 있습니다.
	(역자 주 끝)
	
	중요도 샘플링은 $f(x)$가  음이 아닌 값일 때마다 $p(x)$가 양의 실수라면 unbiased합니다. 또한 이상적으로는 분산을 줄이기 위해서 $p(x)$는 $f(x)$와 상관관계가 있어야 합니다.