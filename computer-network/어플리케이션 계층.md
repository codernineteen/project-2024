- 네트워크 어플리케이션 : 컴퓨터 네트워크가 존재해야 하는 주요 이유 중 하나
-  네트워크 어플리케이션 종류 : 전자메일, 원격 접속, 파일 전송, www, voIP, 온라인 게임

## 네트워크 어플리케이션 원리
- 개발 중심 - 여러 end system에서 동작하고 , network를 이용하여 서로 통신하는 프로그램 작성

## 네트워크 어플리케이션 구조
- 앱 개발자 관점에서 네트워크는 고정
- **앱 구조**를 앱 개발자가 설계
	1. 클라이언트 - 서버 구조
		- 서버는 클라이언트 요청에 응답
		- 클라이언트는 서로 통신을 하지 않음
		- 서버는 fixed IP & always on
		- ex ) web file transfer, remote login, email
		- 트래픽을 분산시키기 위해 하나 이상의 데이터센터를 운용. (비용 발생)
	2.  p2p 구조
		- always on 서버가 있긴 하지만, 최소로 의존
		- peer라는 간헐적으로 연결된 호스트 쌍이 통신.
			- peer는 서비스 사용자 컴퓨터 그 자체
		- ex ) BitTorrent, block chain
		- self scalability
			- 피어들의 요청으로 부하가 생기지만, 동시에 피어들끼리 서비스를 제공하여 부하를 분산시킴.

## 프로세스 통신
- 프로그램끼리 통신하는 방법.
- 운영체제 내부의 프로세스끼리 통신 - inter process communication (운영체제에 구현에 종속적)
- 다른 운영체제끼리의 통신 -> message 교환으로 통신
	- 송신 프로세스가 message를 생성 -> 네트워크로 보냄
	- 수신은 네트워크로부터 message를 받는다.
- 일반적으로 클라이언트 프로세스와 서버 프로세스로 나뉨
	- 클라이언트 예시 : 웹에서 브라우저
	- 웹 서버 : 서버 프로세스
- 좀 더 사전적 정의 : 
	- 통신 세션에서 통신을 초기화 하는 쪽 (communication initialization) - 클라이언트
	- 세션을 시작하기 위해 접속을 기다리는 쪽 - 서버

## 프로세스 <-> 네트워크 인터페이스

- 요약하면, 넷 어플리케이션은 두 프로세스가 쌍을 이루어 message를 교환하는 형태
- message를 내보내기 위한 도구가 바로 ==socket API==?
	  TCP 를 transport layer protocol로 사용한다고 가정할 때,![](../../images/Pasted%20image%2020240422152057.png)
	  앱 개발자는 소켓에 대한 모든 통제권을 갖고, transport layer에 대해서는  protocol 선택, 최대 버퍼 및 세그먼트 크기 등의 parameter 설정만 제한적으로 허용.
	

## 프로세스 주소 배정
- 수신 프로세스를 식별하기 위함
- 인터넷에서는 32bit IP 주소가 사용됌
- 한 호스트가 많은 넷 앱을 실행할 수 있기 때문에, port number가 필요.
	- web server on HTTP : 80
	- SMTP : 25

## 어플리케이션 관점에서 transport layer protocol의 서비스

1. 신뢰적 데이터 전송
	패킷 손실, 비트 에러와 같은 문제를 해결
2. 처리율(네트워크 경로를 따라 두 프로세스 간의 통신 세션에서 송신 프로세스가 수신 프로세스로 비트를 전달할 수 있는 비율)
	프로토콜이 보장하는 natural throughput 이 있음.
	대역폭 민감 어플리케이션 (예를 들면, 멀티미디어) 같은 어플리케이션은 일정 처리율을 요구사항을 갖고있다.
3. 타이밍
	인터넷 전화, 화상 회의, 온라인 게임과 같은 어플리케이션은 데이터 전송 지연에 엄격한 제한을 둔다.
4. 보안
	transport protocol이 종단간의 암호화/복호화를 적용해서 기밀성을 보장할 수 있음.


## TCP가 제공하는 서비스
- 연결지향형:
	- 핸드셰이킹(패킷이 도착할테니 준비해) -> 연결 성립(두 프로세스 사이에 소켓 연결이 확립됌)
	- 이러한 연결을 full-duplex연결이라고 한다.
	- 전송을 마치면 연결을 끊음
- 신뢰적인 데이터 전송 :
	- 앱이 모든 데이터를 올바른 순서로 보내기 위해 TCP에 의존함. 바이트 스트림이 손실되지 않고 무결성을 보장하기 위한 서비스를 TCP가 제공한다.
- 참고 : TCP는 앱 호스트의 이득보다 네트워크 전체의 성능 향상을 위한 서비스(혼잡 제어)를 목표로 함.
## UDP 서비스
- 최소 서비스 모델
- 비연결형
- 비신뢰적인 데이터 전송 - 메세지 수신을 보장하지 않음, 메세지 순서를 보장하지 않음.
- 혼잡 제어가 없음
	- 이 특징 때문에, 통신 주체인 호스트의 이득이 커질 수 있다. (송신 호스트가 원하는 속도로 보낼 수 있기 때문에)
	- 단 중간 링크들에 의해 원하는 속도보다 낮아질 수 있음을 유의해야한다.


## 트랜스포트 계층이 제공하지 않는 서비스

일단 제공하는 서비스는
- TCP의 경우, 신뢰적 전송, 연결성, TLS를 쉽게 지원하여 보안성이 좋음.

제공하지 못하는 요소는 
- 시간/처리율 보장 : 네트워크 자체는 공용이기 때문에 , 지연이 필연적인 상황이 있음. 시간 민감성 앱에 만족스러운 서비스를 제공하는 것은 가능하나, **보장**은 못한다.
	-> 이러한 이유로 인해 많은 시간 민감성 앱들이 혼잡제어로 인한 시간 지연을 막기 위해 UDP를 선호한다. 하지만, 방화벽에 의해서 UDP 트래픽이 막히는 경우가 있어서 이 경우 TCP로 유동적으로 변경할 수 있게 설계되어있다.

## 어플리케이션 레이어 프로토콜
- 어플리케이션 끼리 메세지 형식을 정의하는 것
- 예를 들어, 브라우저 개발자가 RFC HTTP 명세를 그대로 따라서 개발한다면, 어떠한 웹 서버로부터도 웹 페이지를 가져올 수 있다.
- 앱의 네트워크 프로토콜은 앱의 그저 하나의 요소에 불과하다.

---

# 웹과 HTTP

웹의 좋은 점 :
- 온디맨드 - 사용자가 필요로 할 때 컨텐츠를 제공
- 다양한 시각적 데이터들

## HTTP
- ==메세지의 구조== 및 클라-서버가 메세지를 어떻게 교환하는지에 대한 ==행동 정의==
- 웹 페이지의 구성
	- HTML : 마크업 언어로서, 웹 페이지가 갖고 있는 여러 reference object에 대한 정보를 나타낸다.
	- reference object : url로 지정할 수 있는 하나의 파일.
	- url : http://<domain_name>/<path_of_object>
		- http - 프로토콜 이름
		- domain_name : 서버 호스트 주소
		- path_of_object : 참조 객체의 상대 경로
- HTTP 요청의 흐름
	HTTP 클라이언트 TCP 연결 시도 
	-> 브라우저가 소켓 인터페이스로 접속 요청을 시도 
	-> 서버 측 소켓에서 접속 요청을 감지 
	-> HTTP응답 메세지 전송
	 (이 과정에서 데이터 손실 및 손실 복구 방법은 TCP와 하위 프로토콜이 하는 일이라 앱의 입장에서는 고려할 필요가 없다 -E2E  원칙의 장점)
- HTTP 자체는 stateless protocol, 대신 쿠키나 캐시가 상태를 저장함.


## Persistent HTTP vs Non-Persistent HTTP

- 디폴트는 persistent HTTP, 클라-서버 관계에서 비지속 연결을 사용하도록 설정가능.

### non-persistent HTTP
- 연결 : 
	- 접속하려는 웹페이지에 TCP 연결 요청 시도 
	 -> 클라이언트 tcp 소켓으로 http 요청 (index.html)
	 -> 서버 저장장치에서 index를 뽑아내서 메세지에 캡슐화하고, 응답메세지 전송
	 -> 서버는 tcp에게 연결을 끊으라고 지시(일단 클라이언트가 제대로 받을 때까지는 기다림)
	 -> 클라이언트는 응답을 받으면, tcp연결을 중지
	 -> 클라이언트는 html을 파싱해서 참조 객체를 검출하고 해당 객체들에대해서 위에 과정을 다시 반복 (연결 -> 요청 -> 응답 -> 연결 종료)
- HTTP는 클라이언트가 메세지를 어떻게 해석하는지 관심이 없다. (프로토콜이 어플리케이션의 일부 요소라는 사실을 기억하자.)
- 브라우저는 동시성 정도를 조절할 수 있다.
	예를 들어,
	- 10개의 객체를 모두 싱글 스레드로 처리한다. (동시성 최하)
	- 10개의 객체를 10개의 스레드로 동시에 처리한다. (동시성 최대) -> 응답 시간을 줄일 수 있다.
	  
	  결과적으로 아래와 같이 한번의 연결에 대해서 2RTT + 전송 지연 시간이 소요(TCP메세지는 아주 작아서 전송 시간을 무)
	![](../../images/Pasted%20image%2020240422173545.png)


### persistent HTTP

비지속 연결 HTTP의 단점은 
- 요청 객체마다 연결을 생성해야한다. ->긴 응답시간 발생.
- 따라서 tcp버퍼를 할당하고, tcp변수들이 클라-서버 양측에 유지되어야한다. 
클라이언트가 너무 많아지면 서버에 부담이 커짐.

기본 HTTP 사양은 파이프라이닝을 이용한 지속 연결이다.

---

# HTTP 메세지 포맷

### request
- request line : GET / somedir/page.html HTTP/1.1
	요청 라인이라고 불리며,  HTTP 요청 method와 프로토콜 정보 및, 요청 주소를 담고 있다.
	이 요청 라인 이후의 라인들은 header line이라고 불린다.
	보통 method로 GET을 사용하는데 URL 필드로 식별되는 객체를 요청할 때 사용한다.
- 각 줄 사이에는 `\n\r` carriage return 과 line feed가 따른다. 
- host는 웹 프록시 캐시에 사용
- connection : close (지속 연결을 원하지 않는다는 의미.)
- user-agent : 사용자 브라우저 정보
- accept-language : 원하는 자연어를 요청 -> 없으면 기본 버전으로 보냄
- 헤더 필드가 끝나면, carriage return 과 line feed 다음 payload가 뒤따른다.
![](../../images/Pasted%20image%2020240422174239.png)

- payload는 GET에서 비어있고, POST에서 데이터를 담아 보낼 때 주로 사용한다. (JSON, 사용자가 form을 채워서 submit할 때)
![](../../images/Pasted%20image%2020240422174757.png)


### response
- status line : 프로토콜 버전 | 응답 상태 | phrase
	- 200 : 요청 성공
	- 301 : move permanently , 객체가 영원히 이동.
	- 400 : bad request , 요청을 이해할 수 없음
	- 404 : Not found
	- 505 : HTTP version not supported, 서버가 해당 버전을 지원하지 않음.
- Connection : 지속 / 비지속
- Data : 서버에 의해 응답이 생성되고 보낸 날짜와 시간.
- Server : 클라이언트의 user-agent와 유사함.
- Last modified : 네트워크 캐시 서버 캐싱에 매우 중요한 요소
- Content-Length : 송신되는 객체의 바이트 수
- Content-Type : body 데이터 타입.
![](../../images/Pasted%20image%2020240422180816.png)


# 쿠키
stateless HTTP에서 state를 저장하는 요소 -> 사용자 추적

4가지 요소로 구성된다.
 1. http 응답 메세지 쿠키 헤더라인
 2. http 요청 메세지 쿠키 헤더라인
 3. user end-system of client browser, cookie file
 4. backend entry insertion